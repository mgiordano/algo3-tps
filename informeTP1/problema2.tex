\section{Problema 2}

\subsection{Resolución}

\subsubsection{Explicación del problema}
\indent El objetivo de este ejercicio es, dada un red de amistades y 2
investigadores, determinar cuántas veces el entusiasmo que se genera en uno de
ellos se verá fraccionado hasta, finalmente, generar un cierto entusiasmo en el
otro. \\
\indent Esto sucederá sólo en aquellos casos en los cuales estos investigadores
tengan amigos en común. En caso de existir varias redes de amistades
(entendiendose por red de amistad a una conexión de amistades entre ambos
investigadores, sin que haya investigadores repetidos), se debe estudiar el caso
de la más corta, ya que esta red será la que generará el entusiasmo en el
investigador antes que cualquier otra y con la mayor proporción. \\
\indent Si no existiesen amigos en común entre ellos, es decir, si no existe una
red de amistad entre ambos, entonces el entusiasmo generado en uno nunca llegará
al otro, es decir la fracción de entusiasmo que le generará al investigador
destinatario será cero o, como se ha establecido, se indicará con $0$ la
cantidad de veces que éste se verá fraccionado. \\

\subsubsection{Primeros intentos de solución}

\subsubsection{BFS}
El algortimo de búsqueda BFS (por sus siglas en inglés, Breadth-First Search)
consiste en que dado un grafo $G= (V,E)$ y un vértice distinguido $s$, computa
la distancia (mínimo camino entre dos vértices) desde $s$ hasta cualquier
vértice que tenga algún camino simple que lo conecte con $s$.\\
\indent El algoritmo recorre un vértice, lo analiza y luego realiza el mismo
procedimiento con sus vértices adyacentes. Con el fin de no analizar 2 veces el
mismo vértice y así trabajar sólo con caminos mínimos,el algoritmo BFS setea los
vértices con distintos colores:

\begin{itemize}
\item \textit{blanco}: el análisis de vértices no abarcó este vértice en ninguna
instancia.
\item \textit{gris}: para indicar si ya ha sido encontrado y guardado en una
cola para, posteriormente, realizar el análisis de sus vértices adyacentes.
\item \textit{negro}:para indicar que ya se han guardado todos sus vértices
adyacentes para su posterior análisis.
\end{itemize}

El procedimiento BFS va construyendo un árbol BF que tiene cómo raíz a
$s$, como hijos directos de este a todos sus adyacentes, como hijos de esos a
sus respectivos hijos, y así sucesivamente.\\
\indent De esta forma, se crea una relación de orden entre los vértices, orden
establecido por la distancia al vértice $s$ que posee cada uno. Así todos
aquellos nodos que estén a distancia uno de $s$, estarán en el nivel 1 del árbol
BF.\\

\subsubsection{Aplicación de BFS al problema}
\indent \Obs{\textit{Estudiando los casos de tests provistos por la cátedra, 
pudimos observar que, cuando existen más de dos redes de amigos que conectan a
ambos investigadores,
el criterio para elegir una red de amigos, a través de la cuál 
se propaga el entusiasmo, es la que está conformada por la de menor cantidad de
investigadores.} }\\

\indent Antes que nada, realizamos el modelado del problema de esta forma:
Tomamos un grafo genérico $G(V,E)$, donde $V$ es el conjunto de vértices (aka
investigadores) de $G$ y $E$ un conjunto de pares de vértices(aka amistad entre
2 investigadores) , indicando las aristas que unen a dichos vértices en $G$.\\

\indent Dada una red de amigos, para saber cuántas veces se fracciona a la mitad
el entusiasmo del investigador $v_1$ hasta que recibe una porción de este el
investigador $v_n$, asumiendo que $v_1$ y $v_n$ tienen una red que los conecta,
tenemos la siguiente recursión:
\begin{itemize}
 \item Si $v_1$ es amigo de $v_n$, entonces $v_n$ recibe la mitad del entusiasmo
de $v_1$, 
 ya que esta se divide a la mitad una sola vez y, a su vez, existe una única
arista en el camino que conecta a ambos.
 \item Si no son amigos, entonces cada uno de los amigos de $v_1$ reciben la
mitad del 
 entusiasmo de $v_1$. Asumamos que $v_n$ se encuentra a distancia $n-1$ de $v_1$
y 
 tomemos el único amigo de $v_1$, siendo este
 uno de los vértices del camino mínimo que une a $v_1$ con $v_n$,
 al que llamaremos $v_2$. 
 Entre $v_1$ y $v_2$ hay una arista ($v_2$ se encuentra a distancia 1 de $v_1$)
y el
 entusiasmo de $v_1$ se fracciona una sola vez.
 Ahora, entre $v_2$ y su amigo $v_3$, siendo este
 uno de los vértices del camino mínimo que une a $v_1$ con $v_n$, entre $v_2$ y
$v_3$
 hay una arista ($v_3$ se encuentra a distancia 1 de $v_2$). Entonces, entre
$v_3$ y $v_1$ 
 hay 2 aristas ($v_3$ se encuentra a distancia 2 de $v_1$) y el
 entusiasmo de $v_1$ se fracciona una vez más que para $v_2$, es decir el
 entusiasmo de $v_1$ se fracciona 2 veces hasta llegar a $v_3$. Generalizando,
 para cualquier amigo $v_k$, con 2 $\leq$ k $\leq$ n:
 \begin{itemize}
  \item entre $v_k$ y $v_1$ hay k-1 aristas, es decir, se encuentran a distancia
k-1;
  \item el entusiasmo de $v_1$ se fracciona k-1 veces hasta llegar a $v_k$, y 
 \end{itemize}
\end{itemize}
\indent\indent Entonces, la cantidad de veces que se fracciona el entusiasmo de
$v_1$ hasta llegar a $v_n$ 
 es equivalente a la cantidad de aristas que exiten entre esos 2, es decir la
distancia entre ellos que es n-1.
 Es por esto que pudimos establecer la resolución del problema mediante
el uso del algortimo BFS, ya que la cantidad de fracciones que se produce sobre
el entusiasmo de $v_1$ hasta que genera algún nivel de entusiasmo en $v_n$, es
equivalente a calcular la distancia desde $v_1$ hasta $v_n$, que es lo que
calcula el BFS.\\

\indent Teóricamente, si la red de amigos en común más corta que
une $v_1$ con $v_n$ tiene un longitud $\delta$($i_1$,$v_n$) y $v_1$ se
entusiasma en un valor medible $e$,
luego $v_n$ se
entusiasmará con un nivel
\Gather{e' = \frac{e}{2.\delta(v_1,v_n)}.}

\indent Nuestra implementación trabaja con listas de adyacencia. Cada
investigador tiene asociada una lista donde están almacenados sus amigos (los
vértices adyacentes).\\

\indent En nuestra implementación, los investigadores poseen un campo estado que
puede tener alguno de los siguientes valores:

\begin{itemize}
\item \textit{no encontrado}: sería el equivalente al color blanco del algoritmo
de BFS, indicando que el recorrido del análisis de las amistades jamás abarcó
éste investigador. Inicialmente todos los investigadores están seteados
en este estado.
\item \textit{encontrado}: sería el equivalente al color gris del algoritmo de
BFS, indicando que ya se ha guardado este investigador en una cola para,
posteriormente, realizar el análisis sobre sus amistades.
\item \textit{visitado}: sería el equivalente al color negro del algoritmo de
BFS, indicando que ya se han guardado todos sus vértices adyacentes para su
análisis.
\end{itemize}

\hspace{-0.5cm}La función BFS realiza los siguientes pasos:
\begin{enumerate}
 \item Setea el estado del investigador fuente $s$ en gris.
 \item Encola $s$ en una cola vacía $c$.
 \item Desencola $c$ y ese elemento se almacena en $i$.
 \item Encola en $c$ los amigos de $i$.
 \item Setea el estado de $i$ en negro.
 \item Repite desde el paso 3 hasta que la cola quede vacía.
\end{enumerate}

\indent Una vez visitados todos los investigadores, se tiene como
postcondición que a todos se les ha seteado la distancia a $s$. En caso de que
no existiera un 
camino hacia $s$, la distancia por defecto no se modifica. 
El resultado de la función es el campo distancia del investigador destinatario
en caso de existir
un camino entre él y $s$, o 0 en caso contrario.

\subsubsection{Pseudoalgoritmo}
\indent Para resolver el problema, utilizamos una función  llamada BFS, que toma
2 datos de tipo investigador, donde investigador es una clase que posee la
siguiente información sobre el investigador:
\begin{itemize}
	\item nombre
	\item estado (no encontrado, encontrado, visitado)
	\item lista de amistades directas
	\item distancia al vértice desde el cuál se quiere calcular la distancia
\end{itemize}
\indent La función que resuelve el problema propiamente dicho, se llama BFS, y
se encuentra dentro de la clase relaciones. Esta clase contiene:

\begin{itemize}
\item una lista de todos los investigadores.
\item un investigador fuente.
\item un investigador destino.
\end{itemize}
\indent La función BFS lo que hace es una traducción del algortimo de BFS
\footnote{Introduction to algorithms, Third Edition; Thomas H. Cormen}  de la
siguiente forma:\\

$BFS$(invfuente, invdestino)\\
\indent\indent invfuente.estado = encontrado\\
\indent\indent invfuente.distancia = 0\\
\indent\indent cola= $\emptyset$ \\
\indent\indent encolar(cola, invfuente)\\
\indent\indent \textbf{while}  cola $\neq$ $\emptyset$\\
\indent\indent\indent actual = desencolar(cola)\\
\indent\indent\indent \textbf{for}  v $\in$ amigos(actual)\\
\indent\indent\indent\indent\ \textbf{if} v.estado == no encontrado\\
\indent\indent\indent\indent\indent v.estado = encontrado\\
\indent\indent\indent\indent\indent v.distancia = actual.distancia +1\\
\indent\indent\indent\indent\indent encolar (cola, v) \\
\indent\indent\indent actual.estado = visitado\\ 
\indent\indent \textbf{if} invdestino.distancia == $\infty$\\
\indent\indent\indent return 0\\
\indent\indent \textbf{else}\\ 
\indent\indent\indent return invdestino.distancia\\

\subsection{Complejidad}
\subsubsection{Análisis de complejidad}
\indent Analizamos el código de la función BFS línea por línea, siguiendo los
siguientes criterios:
\begin{itemize}
 \item Asignar valores enteros o chars acotados y comparar chars acotados
 tienen complejidad O(1)
 \item Pedir alguna de las variables del tipo Investigador tiene una complejidad
$O(1)$, 
 ya que se puede acceder a estas directamente.
 \subitem La función constructora del tipo Investigador tiene una complejidad 
 O($|$nombre$|$)+O($|$estado$|$)+O(crear una lista vacia)+O(pedir max value)=
 O(1)+O(1)+O(crear una lista vacia)+O(1)= O(crear una lista vacia) ;
 ya que los nombres de los investigadores y los strings que indican el estado
 son strings acotados por el más largo, que sabemos que será finito, por ende toman O(1), y
 pedir el max value toma O(1)
 \item Las funciones del tipo genérico ''Queue''tienen la siguiente complejidad:
 \subitem crear una cola= O(crear lista enlazada)
 \subitem ver si es vacía= O()
 \subitem encolar= O()
 \subitem desencolar= O()
 \item Las funciones del tipo genérico ''Linked List'' tienen
 la siguiente complejidad:
 \subitem crear una lista enlazada vacía= O()
 \subitem pedir el índice de un elemento= O()
 \item  Las funciones del tipo genérico ''List Iterator'' tienen
 la siguiente complejidad:
 \subitem crear un iterador a una lista= O()
 \subitem ver si hay siguiente= O()
 \subitem avanzar el iterador= O()
 
\end{itemize}

\indent Dado que estas son las únicas funciones que utilizamos en el código de
la función BFS, todas las líneas tienen complejidad O(1)\\
\indent Sólo falta analizar cuántas veces iteran los 2 whiles, para saber la 
complejidad de los mismos\\

%ESTO PARA ABAJO CAMBIA SI ALGUNA DE LAS FUNCIONES DENTRO DEL WHILE NO TOMA O(1)
\indent La complejidad del while más grande está determinada por la cantidad de veces que itera 
y cada iteración toma O(cantidad de iteraciones del while anidado), es por esto que
primero realizaremos el análisis del while anidado.\\

\indent El while anidado itera la lista de adyacencia de cada investigador $i$, entonces
el while iterará $a_i$ veces, donde $a_i$ es el largo
de la lista de adyacencia de $i$.\\

\indent Ahora podemos determinar la complejidad del while más abarcativo. Como habíamos
establecido antes, la complejidad de este será 
\Gather{O(cantidad\ de\ veces\ que\ itera) * O(cantidad\ de\ veces\ que\ itera\ el\ while\ anidado)}

\indent Este ciclo iterará hasta que la cola $c$ quede vacía. $C$ es la cola donde se irá guardando
sólo una vez los investigadores. Entonces esta cola no quedará vacía hasta que se haya encolado y desencolado 
a todos los investigadores de ella. Por ende, este while itera tantas veces como investigadores haya.\\

\indent Además, por cada iteración, este while toma una complejidad O($a_i$), donde $a_i$ es el largo
de la lista de adyacencia de $i$, que es el
investigador que se ha desencola ni bien se entra en el while. Como este while itera una vez para cada investigador,
la complejidad que tomará finalmente será 
\Gather{(\sum_{i=1}^{k}(a_i))* k}, donde k es la cantidad de investigadores.

\indent Observar que la sumatoria, es una sumatoria de todas las listas de adyacencia, entonces, su resultado es 2a,
ya que recorre 2 veces cada amistad (una vez por cada investigador involucrado), como 2 es una constante, no afecta
en la complejidad temporal de la función. 
Luego la complejidad de la función BFS es 
\Gather{O(cantidad\ de\ investigadores)*O(cantidad\ de\ amistades)}

\subsection{Análisis de casos de test}
